#include <string>
#include <vector>
#include <memory>

// Turret class - offensive structure
class Turret : public Building {
private:
    int attackDamage;
    int attackRange;
    int attacksPerTurn;
    int attacksRemaining;
    bool automated;  // If true, attacks automatically nearby enemies
    
public:
    Turret(Player* owner, Tile* location)
        : Building(40, 20, 3, "Turret", owner, location),
          attackDamage(10), attackRange(2), attacksPerTurn(1), attacksRemaining(1), automated(false) {}
    
    int getAttackDamage() const { return attackDamage; }
    int getAttackRange() const { return attackRange; }
    int getAttacksPerTurn() const { return attacksPerTurn; }
    int getAttacksRemaining() const { return attacksRemaining; }
    bool isAutomated() const { return automated; }
    
    void setAutomated(bool auto_mode) {
        automated = auto_mode;
    }
    
    void upgrade() {
        attackDamage += 5;
        healthPoints += 10;
        maintenanceCost += 1;
    }
    
    bool canAttack() const {
        return attacksRemaining > 0 && !isDestroyed;
    }
    
    void attack(Building* target) {
        if (canAttack()) {
            target->takeDamage(attackDamage);
            attacksRemaining--;
        }
    }
    
    void update(int turn) override {
        // Reset attacks at the beginning of player's turn
        attacksRemaining = attacksPerTurn;
        
        // If automated, the game logic would handle automatic attacks here
    }
    
    std::string getDescription() const override {
        return Building::getDescription() + " - Damage: " + std::to_string(attackDamage) + 
               ", Range: " + std::to_string(attackRange) + 
               ", Attacks: " + std::to_string(attacksRemaining) + "/" + std::to_string(attacksPerTurn);
    }
};
